package viaduct.service.runtime

import graphql.GraphQL
import graphql.execution.ExecutionStrategy
import graphql.execution.instrumentation.Instrumentation
import graphql.execution.preparsed.PreparsedDocumentProvider
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import viaduct.engine.api.ViaductSchema
import viaduct.service.runtime.ViaductSchemaRegistryBuilder.AsyncScopedSchema

class ViaductSchemaRegistry internal constructor(
    // This is generated by the "registerSchema" that uses the "PublicSchemaRegistration" factories to register the schemas.
    private val scopedSchemas: ConcurrentHashMap<String, ViaductSchema> = ConcurrentHashMap(),
    // These are generated by the "registerSchema" method that allows for lazy loading and using schema compute blocks.  It lazy loads the schema.
    private val asyncScopedSchemas: ConcurrentHashMap<String, AsyncScopedSchema> = ConcurrentHashMap(),
    private val schemaDocumentProvider: ConcurrentHashMap<ViaductSchema, PreparsedDocumentProvider> = ConcurrentHashMap(),
    private val fullSchema: ViaductSchema,
) {
    private val enginesById: ConcurrentMap<String, Lazy<GraphQLEngine>> = ConcurrentHashMap()
    private val enginesBySchema: ConcurrentMap<ViaductSchema, GraphQLEngine> = ConcurrentHashMap()

    data class GraphQLEngine(
        val schema: ViaductSchema,
        val graphQL: GraphQL
    )

    internal fun registerSchema(
        instrumentation: Instrumentation,
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
    ) {
        scopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                { schema },
                instrumentation,
                { schemaDocumentProvider[schema]!! },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy
            )
        }

        asyncScopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                schema.schemaComputeBlock,
                instrumentation,
                schema.documentProviderFactory ?: { CachingPreparsedDocumentProvider() },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy,
                schema.lazy
            )
        }
    }

    /**
     * Provide access to full schema in schemaRegistry so we don't have to pass ViaductSchemaRegistryBuilder around to get full schema
     * The catch is that it is called before `registerSchema`, aka before schemaRegistry is fully built. Given the immutability
     * of `fullSchema` variable, it's probably still a good compromise.
     */
    fun getFullSchema(): ViaductSchema {
        return fullSchema
    }

    private fun registerSchemaInternal(
        schemaId: String,
        schemaComputeBlock: () -> ViaductSchema,
        instrumentation: Instrumentation,
        documentProviderFactory: ((ViaductSchema) -> PreparsedDocumentProvider),
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
        lazy: Boolean = false
    ) {
        enginesById.computeIfAbsent(schemaId) {
            lazy {
                val schema = schemaComputeBlock()
                enginesBySchema.computeIfAbsent(schema) {
                    GraphQLEngine(
                        schema,
                        GraphQL.newGraphQL(schema.schema)
                            .preparsedDocumentProvider(documentProviderFactory(schema))
                            .queryExecutionStrategy(queryExecutionStrategy)
                            .mutationExecutionStrategy(mutationExecutionStrategy)
                            .subscriptionExecutionStrategy(subscriptionExecutionStrategy)
                            .instrumentation(instrumentation)
                            .build()
                    )
                }
            }
        }.also {
            if (!lazy) {
                it.value
            }
        }
    }

    fun getSchema(schemaId: String): ViaductSchema? = enginesById[schemaId]?.value?.schema

    fun getEngine(schemaId: String): GraphQL? = enginesById[schemaId]?.value?.graphQL
}
