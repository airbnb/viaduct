package viaduct.service.runtime

import graphql.GraphQL
import graphql.execution.ExecutionStrategy
import graphql.execution.instrumentation.Instrumentation
import graphql.execution.preparsed.PreparsedDocumentProvider
import graphql.schema.GraphQLSchema
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap
import viaduct.service.runtime.SchemaRegistryBuilder.AsyncScopedSchema

class GraphQLSchemaRegistry internal constructor(
    // This is generated by the "registerSchema" that uses the "PublicSchemaRegistration" factories to register the schemas.
    private val scopedSchemas: ConcurrentHashMap<String, GraphQLSchema> = ConcurrentHashMap(),
    // These are generated by the "registerSchema" method that allows for lazy loading and using schema compute blocks.  It lazy loads the schema.
    private val asyncScopedSchemas: ConcurrentHashMap<String, AsyncScopedSchema> = ConcurrentHashMap(),
    private val schemaDocumentProvider: ConcurrentHashMap<GraphQLSchema, PreparsedDocumentProvider> = ConcurrentHashMap(),
    private val fullSchema: GraphQLSchema,
) {
    private val enginesById: ConcurrentMap<String, Lazy<GraphQL>> = ConcurrentHashMap()
    private val enginesBySchema: ConcurrentMap<GraphQLSchema, GraphQL> = ConcurrentHashMap()

    internal fun registerSchema(
        instrumentation: Instrumentation,
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
    ) {
        scopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                { schema },
                instrumentation,
                { schemaDocumentProvider[schema]!! },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy
            )
        }

        asyncScopedSchemas.forEach { (id, schema) ->
            registerSchemaInternal(
                id,
                schema.schemaComputeBlock,
                instrumentation,
                schema.documentProviderFactory ?: { CachingPreparsedDocumentProvider() },
                queryExecutionStrategy,
                mutationExecutionStrategy,
                subscriptionExecutionStrategy,
                schema.lazy
            )
        }
    }

    /**
     * Provide access to full schema in schemaRegistry so we don't have to pass SchemaRegistryBuilder around to get full schema
     * The catch is that it is called before `registerSchema`, aka before schemaRegistry is fully built. Given the immutability
     * of `fullSchema` variable, it's probably still a good compromise.
     */
    fun getFullSchema(): GraphQLSchema {
        return fullSchema
    }

    private fun registerSchemaInternal(
        schemaId: String,
        schemaComputeBlock: () -> GraphQLSchema,
        instrumentation: Instrumentation,
        documentProviderFactory: ((GraphQLSchema) -> PreparsedDocumentProvider),
        queryExecutionStrategy: ExecutionStrategy,
        mutationExecutionStrategy: ExecutionStrategy,
        subscriptionExecutionStrategy: ExecutionStrategy,
        lazy: Boolean = false
    ) {
        enginesById.computeIfAbsent(schemaId) {
            lazy {
                val schema = schemaComputeBlock()
                enginesBySchema.computeIfAbsent(schema) {
                    GraphQL.newGraphQL(schema)
                        .preparsedDocumentProvider(documentProviderFactory(schema))
                        .queryExecutionStrategy(queryExecutionStrategy)
                        .mutationExecutionStrategy(mutationExecutionStrategy)
                        .subscriptionExecutionStrategy(subscriptionExecutionStrategy)
                        .instrumentation(instrumentation)
                        .build()
                }
            }
        }.also {
            if (!lazy) {
                it.value
            }
        }
    }

    fun getSchema(schemaId: String): GraphQLSchema? = getEngine(schemaId)?.graphQLSchema

    fun getEngine(schemaId: String): GraphQL? = enginesById[schemaId]?.value
}
