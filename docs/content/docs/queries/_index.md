---
title: Queries
description: How Viaduct executes queries.
weight: 10
---

# Queries

## Generated Resolver Base Classes

In Viaduct, *all* tenant code is provided in the form of either a *node resolver* or a *field resolver*.  Either kind of resolver is implemented by providing a subclass of a *resolver base class* generated by the Viaduct framework..  Resolver base classes are best understood through example.  Let’s look at our simple schema again:

```graphql
type User implements Node {
  id: ID!
  firstName: String
  lastName: String
  displayName: String @resolver
}
```

Note that we’ve added `@resolver` to the `displayName` field, which indicates that we want to provide a field-resolver for that field.

For this example, we generate two base classes, one for the node resolver for the `User` type, and one for the field resolver for the `User.displayName` field:

```kotlin
object Nodes {
  abstract class User {
    open suspend fun resolve(ctx: Context): viaduct.api.grts.User

    class Context: NodeExecutionContext<viaduct.api.grts.User>
  }
}

object UserResolvers {
  abstract class DisplayName {
    open suspend fun resolve(ctx: Context): String?

    class Context: FieldExecutionContext<User, NoArguments, NotComposite>
  }
}
```

(we’ll discuss the `Context` types in later sections).

As a tenant developer, you provide the node resolver for `User` by writing a subclass of `Nodes.User` and the field resolver for `User.displayName` by writing a subclass of `UserResolvers.DisplayName`.  If your tenant module defines other node types, resolver base classes for those would also be defined in `NodeResolvers`, and if it asked for more field resolvers on the `User` type, base classes for those additional resolvers would be defined in `UserFieldResolvers`.

## Responsibility Sets

"Responsibility sets" (also known as "responsibility selection sets") are an important concept in the Viaduct API.  Every resolver is "responsible" for returning the fields in its responsibility set.  This is all fields, including nested fields, that themselves do not have a resolver.  In our example, the node resolver for `User` is responsible for returning the `id`, `firstName`, and `lastName` fields, but not the `displayName` field, because that field has its own resolver.  If the `User` type had a field whose type is a `Node` – for example, a `listings: [Listing]` field, the `User`’s node resolver would *not* be responsible for resolving that field, because node values are resolved by their node resolvers.

In our example, the `displayName` field has a scalar type, so the responsibility set for that resolver is just that scalar value.  If `displayName` returned a (non-node) GraphQL object type, then the `displayName` resolver would be responsible for all fields (recursively) in that object type that do not have their own resolvers.

### ExecutionContext

When implementing a resolver, you have access to a number of parameters that are bundled into what we call *execution contexts*.  Both `NodeExecutionContext` and `FieldExecutionContext` implement the `ExecutionContext` base interface:

```kotlin
interface ExecutionContext {
  suspend fun <T: Query> query(selections: SelectionSet<T>): T

  fun <T: NodeObject> nodeFor(id: GlobalID<T>): T
  fun <T: Object> globalIDFor(type: Type<T>, internalID: String): GlobalID<T>

  fun <T : CompositeOutput> selectionsFor(
    type: Type<T>,
    selections: @Selections String,
    variables: Map<String, Any?> = emptyMap()
  ): SelectionSet<T>
}
```

The type-bounds found in this interface – for example, `Object` and `Struct` – are tagging-types for the GRTs of various flavors of GraphQL types – in our examples, GRTs for (`Object`) GraphQL object types and (`Struct`) GraphQL object and input types (i.e., types that have fields).  Here is what these functions do:

* `query` kicks off a subquery, i.e., a GraphQL query operation on the full "central schema" served by Viaduct.
* `nodeFor` returns a "node reference," which are described in their own subsection below.
* `globalIdFor` returns a global-identifier.
* `selectionsFor` constructs a selection set.  The `selections` argument is the text that is either a set of selections, or a fragment on type `T`.  (See  discussion on selection texts.)

